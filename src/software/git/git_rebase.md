---
title: rebase
icon: laptop-code
order: 3
category: Git
tag:
  - Git
  - shell
---

## 自动变基
```bash
git config --global pull.rebase true
git config --global rebase.autoStash true
```
### 原理
如果不想了解原理的话，则执行完上面两条命令就可以去开心地变基了，完全没有问题。如果想了解一些原理，可以接着往下看。下面我们来详细解释一下这两条命令的原理：

首先，我们要搞清楚一点：什么时机是变基的时机？一般理解是推送的时候，其实不是，而是从拉取的时候就要开始变基了，因为你拉取的时候，服务器上可能已经有新代码了，所以要变基也是在这个时候，一旦发现有新基础了，则立马变掉。所以，通常情况下，我们拉取新代码无非就是一个命令：git pull，但现在我们要变基拉取，就需要用git pull --rebase。但是每次这样执行命令就会很麻烦，而且你在vscode里也没有办法自动加这个参数，所以为了方便起见，我们就设置一下第一条命令，这样每次拉取它都会自动变基。

但是自动变基往往会带来一个额外的问题，那就是每次当你手头有正在编辑的文件的时候，它就说它无法变基，因为你的工作区不干净。为什么不变基的时候没有这个问题，而一旦选择了自动变基，工作区就必须保持干净呢？因为变基的操作原理是它需要先把你本地代码库里还没有推送的那部分提交反向释放到工作区，然后从服务器拉取新代码，再以新代码为基础把工作区里的修改附加上去，因为有这个过程，所以它必须要求你的服务区是干净的。为此git提了两个建议：要么你把所有修改先全部都commit到本地，要么你把它们都stash保存起来。首先说，commit肯定不是一个好主意，因为很有可能这时候我们的工作做到一半，还不适合commit，如果每次pull都commit一下的话，那么分支树上会多出很多无用的节点。那只剩下最后一个选择，就是每次pull之前都stash一下，pull完了之后再把stash的内容pop出来，但这样岂不是更麻烦？所以这里我们用第二条命令设置一下，每次rebase的时候都自动把我们工作区里的内容自动stash进去，rebase完成之后再自动恢复出来。

其余要注意的就是有冲突的时候，如果有冲突，则合并完冲突之后，执行一下git rebase --continue就好了，其它和原先的用法没有任何区别。

摘抄 ：[两条命令让你的git自动变基](https://segmentfault.com/a/1190000040712052)

## 合并最近两次提交
```bash
git rebase -i HEAD~2
```
::: info 选项说明
pick：保留该commit（缩写:p）

reword：保留该commit，但我需要修改该commit的注释（缩写:r）

edit：保留该commit, 但我要停下来修改该提交(不仅仅修改注释)（缩写:e）

squash：将该commit和前一个commit合并（缩写:s）用的比较多

fixup：将该commit和前一个commit合并，但我不要保留该提交的注释信息（缩写:f）

exec：执行shell命令（缩写:x）

drop：我要丢弃该commit（缩写:d）
![rebase](./images/git-rebase.png) 
:::

