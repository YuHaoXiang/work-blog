import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as l,c as i,b as a}from"./app-DrsE8OIX.js";const t="/work-blog/assets/run_about-Zr6ARr-6.jpg",n="data:image/jpeg;base64,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",s={},o=a('<h2 id="注释" tabindex="-1"><a class="header-anchor" href="#注释"><span>注释</span></a></h2><p>&quot;#&quot; 开头的就是注释，被编译器忽略</p><ul><li>单行注释: #</li><li>多行注释: :&lt;</li></ul><h2 id="变量" tabindex="-1"><a class="header-anchor" href="#变量"><span>变量</span></a></h2><h3 id="变量类型" tabindex="-1"><a class="header-anchor" href="#变量类型"><span>变量类型</span></a></h3><p>运行shell时，会同时存在三种变量:</p><ol><li>局部变量:局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。</li><li>环境变量:所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。</li><li>shell变量:shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行</li></ol><h3 id="变量操作" tabindex="-1"><a class="header-anchor" href="#变量操作"><span>变量操作</span></a></h3><ul><li>创建普通变量: name=&quot;test&quot; （=两边不可有空格）</li><li>创建只可函数体中使用的局部变量: local name=&quot;test&quot; （使用local修饰的变量在函数体外无法访问，并且local只能在函数体内使用）</li><li>使用变量: echo $name 或者 echo ${name} （推荐使用大括号版）</li><li>变量重新赋值: name=&quot;new_test&quot; （将原值覆盖）</li><li>只读变量: name=&quot;only_read&quot; -&gt; readonly name （使用readonly标识后的变量，不可被修改）</li><li>删除变量: unset name; （删除之后不可访问，删除不掉只读变量）</li></ul><h3 id="字符串变量" tabindex="-1"><a class="header-anchor" href="#字符串变量"><span>字符串变量</span></a></h3><h3 id="单引号" tabindex="-1"><a class="header-anchor" href="#单引号"><span>单引号</span></a></h3><ul><li>单引号变量var=&#39;test&#39; ，只能原样输出，变量无效</li><li>单引号中不能出现一个单独的单引号，转义也不可以</li></ul><h3 id="双引号" tabindex="-1"><a class="header-anchor" href="#双引号"><span>双引号</span></a></h3><ul><li>双引号变量var=&quot;my name is ${name}&quot;，变量有效</li><li>可出现转义符</li></ul><h3 id="拼接字符串" tabindex="-1"><a class="header-anchor" href="#拼接字符串"><span>拼接字符串</span></a></h3><ul><li>中间无任何+，之类的字符</li><li><code>name=&quot;this is&quot;&quot; my name&quot;;</code> <code>name=&quot;this is my name&quot;;</code> <code>name=&quot;this&quot; is &quot;my name&quot;</code> 等效</li><li><code>name=&#39;this is&#39;&#39; my nam&#39;;</code> <code>name=&#39;this is my name&#39;;</code> <code>name=&#39;this&#39; is &#39;my name&#39;</code> 等效</li></ul><h3 id="获取字符串长度" tabindex="-1"><a class="header-anchor" href="#获取字符串长度"><span>获取字符串长度</span></a></h3><ul><li>在${}中使用“#”获取长度</li><li><code>name=&quot;test&quot;;</code></li><li><code>echo ${#name};</code> # 输出为4</li></ul><h3 id="提取子字符串" tabindex="-1"><a class="header-anchor" href="#提取子字符串"><span>提取子字符串</span></a></h3><ul><li>1:4 从第2个开始 往后截取4个字符</li><li>::4 从第一个字符开始 往后截取4个字符</li><li><code>name=&quot;this is my name&quot;;</code></li><li><code>echo ${name:1:4}</code> #输出 is i</li><li><code>echo ${name::4}</code> #输出 this</li></ul><h2 id="数组" tabindex="-1"><a class="header-anchor" href="#数组"><span>数组</span></a></h2><p>bash只支持一维数组，不支持多维数组</p><ul><li><p>定义数组:<code>array_name=(li wang xiang zhang)</code> （小括号做边界、使用空格分离）</p></li><li><p>单独定义数组的元素: <code>array_para[0]=&quot;w&quot;; array_para[3]=&quot;s&quot;</code> （定义时下标不连续也可以）</p></li><li><p>赋值数组元素:<code>array_name[0]=&quot;zhao&quot;;</code></p></li><li><p>获取数组元素:</p><ul><li><code>array_name[0]=&quot;li&quot;</code></li><li><code>array_name[3]=&quot;zhang&quot;</code></li><li><code>echo ${array_name[0]}</code> # 输出&quot;li&quot;</li><li><code>echo ${array_name[1]}</code> # 输出&quot; &quot;</li><li><code>echo ${array_name[3]}</code> # 输出&quot;zhang&quot;</li><li><code>echo ${array_name[@]}</code> # 输出&quot;li zhang&quot; 输出数组所有元素，没有元素的下标省略</li></ul></li><li><p>取得元素个数:<code>${#array_name[@]}</code>或者<code>${#array_name}</code></p></li><li id="array_name[1]"><p>取得单个元素长度:$</p></li><li><p>取得元素个数:<code>${#array_name[@]}</code>或者<code>${#array_name}</code></p></li><li><p>取得单个元素长度:<code>${#array_name[1]}</code></p></li></ul><h2 id="参数传递" tabindex="-1"><a class="header-anchor" href="#参数传递"><span>参数传递</span></a></h2><ul><li>获取参数值: <ul><li>$0 : 固定，代表执行的文件名</li><li>$1 : 代表传入的第1个参数</li><li>$n : 代表传入的第n个参数3</li></ul></li><li>$#:参数个数</li><li>$<em>: 以一个单字符串显示所有向脚本传递的参数。如&quot;$</em>&quot;用「&quot;」括起来的情况、以&quot;$1 $2 … $n&quot;的形式输出所有参数</li><li>$@:与$*相同，但是使用时加引号，并在引号中返回每个参数。</li><li>$$:脚本运行的当前进程号</li><li>$！:后台运行的最后一个进程的ID</li><li>$?: 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</li><li>$* 与 $@ 区别 <ul><li>相同点:都是引用所有参数。</li><li>不同点:只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 &quot; * &quot; 等价于 &quot;1 2 3&quot;（传递了一个参数），而 &quot;@&quot; 等价于 &quot;1&quot; &quot;2&quot; &quot;3&quot;（传递了三个参数）。</li></ul></li></ul><h2 id="运算符" tabindex="-1"><a class="header-anchor" href="#运算符"><span>运算符</span></a></h2><h3 id="算数运算" tabindex="-1"><a class="header-anchor" href="#算数运算"><span>算数运算</span></a></h3><ul><li><ul><li>、-、*、\\ : 乘号前必须加\\进行转义才可以进行乘法运算</li></ul></li><li>加法运算 <ul><li><code>val=`expr 2 + 2`</code> （使用linux命令expr进行辅助运算）</li><li><code>val=$[2+2]</code> （4个空格不是必要的，不同于条件判断）</li><li><code>val=$((2+2))</code></li></ul></li></ul><h3 id="数字关系运算符" tabindex="-1"><a class="header-anchor" href="#数字关系运算符"><span>数字关系运算符</span></a></h3><p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字。 下面假定变量 a 为 10，变量 b 为 20</p><ul><li>-eq :检测两个数是否相等，相等返回 true。 <code>[ $a -eq $b ]</code> 返回 false。</li><li>-ne: 检测两个数是否不相等，不相等返回 true。 <code>[ $a -ne $b ]</code> 返回 true。</li><li>-gt: 检测左边的数是否大于右边的，如果是，则返回 true。 <code>[ $a -gt $b ]</code> 返回 false。</li><li>-lt : 检测左边的数是否小于右边的，如果是，则返回 true。 <code>[ $a -lt $b ]</code> 返回 true。</li><li>-ge: 检测左边的数是否大于等于右边的，如果是，则返回 true。 <code>[ $a -ge $b ]</code> 返回 false。</li><li>-le : 检测左边的数是否小于等于右边的，如果是，则返回 true。 <code>[ $a -le $b ]</code> 返回 true。</li></ul><h3 id="字符串运算符" tabindex="-1"><a class="header-anchor" href="#字符串运算符"><span>字符串运算符</span></a></h3><p>下表列出了常用的字符串运算符，假定变量 a 为 &quot;abc&quot;，变量 b 为 &quot;efg&quot;:</p><ul><li>= :检测两个字符串是否相等，相等返回 true。 <code>[ $a = $b ]</code> 返回 false。</li><li>!= :检测两个字符串是否相等，不相等返回 true。 <code>[ $a != $b ]</code> 返回 true。</li><li>-z :检测字符串长度是否为0，为0返回 true。 <code>[ -z $a ]</code> 返回 false。</li><li>-n :检测字符串长度是否为0，不为0返回 true。 <code>[ -n &quot;$a&quot; ]</code> 返回 true。</li><li>$ :检测字符串是否为空，不为空返回 true。 <code>[ $a ]</code> 返回 true。</li></ul><h3 id="布尔运算符" tabindex="-1"><a class="header-anchor" href="#布尔运算符"><span>布尔运算符</span></a></h3><p>下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20:</p><ul><li>! :非运算，表达式为 true 则返回 false，否则返回 true。 <code>[ ! false ]</code> 返回 true。</li><li>-o :或运算，有一个表达式为 true 则返回 true。 <code>[ $a -lt 20 -o $b -gt 100 ]</code> 返回 true。</li><li>-a :与运算，两个表达式都为 true 才返回 true。 <code>[ $a -lt 20 -a $b -gt 100 ]</code> 返回 false。</li></ul><h3 id="逻辑运算符" tabindex="-1"><a class="header-anchor" href="#逻辑运算符"><span>逻辑运算符</span></a></h3><p>以下介绍 Shell 的逻辑运算符，假定变量 a 为 10，变量 b 为 20:</p><ul><li>&amp;&amp; :逻辑的 AND。 <code>[[ $a -lt 100 &amp;&amp; $b -gt 100 ]]</code> 返回 false</li><li>|| :逻辑的 OR。 <code>[[ $a -lt 100 || $b -gt 100 ]]</code> 返回 true</li></ul><h3 id="文件运算符" tabindex="-1"><a class="header-anchor" href="#文件运算符"><span>文件运算符</span></a></h3><ul><li>-b file :检测文件是否是块设备文件，如果是，则返回 true。 <code>[ -b $file ]</code> 返回 false。</li><li>-c file :检测文件是否是字符设备文件，如果是，则返回 true。 <code>[ -c $file ]</code> 返回 false。</li><li>-d file :检测文件是否是目录，如果是，则返回 true。 <code>[ -d $file ]</code> 返回 false。</li><li>-f file :检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 <code>[ -f $file ]</code> 返回 true。</li><li>-g file :检测文件是否设置了 SGID 位，如果是，则返回 true。 <code>[ -g $file ]</code> 返回 false。</li><li>-k file :检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。 <code>[ -k $file ]</code> 返回 false。</li><li>-p file :检测文件是否是有名管道，如果是，则返回 true。 <code>[ -p $file ]</code> 返回 false。</li><li>-u file :检测文件是否设置了 SUID 位，如果是，则返回 true。 <code>[ -u $file ]</code> 返回 false。</li><li>-r file :检测文件是否可读，如果是，则返回 true。 <code>[ -r $file ]</code> 返回 true。</li><li>-w file :检测文件是否可写，如果是，则返回 true。 <code>[ -w $file ]</code> 返回 true。</li><li>-x file :检测文件是否可执行，如果是，则返回 true。 <code>[ -x $file ]</code> 返回 true。</li><li>-s file :检测文件是否为空（文件大小是否大于0），不为空返回 true。 <code>[ -s $file ]</code> 返回 true。</li><li>-e file :检测文件（包括目录）是否存在，如果是，则返回 true。 <code>[ -e $file ]</code> 返回 true。</li></ul><h2 id="执行相关" tabindex="-1"><a class="header-anchor" href="#执行相关"><span>执行相关</span></a></h2><h3 id="命令替换" tabindex="-1"><a class="header-anchor" href="#命令替换"><span>命令替换</span></a></h3><p>命令替换与变量替换差不多，都是用来重组命令行的，先完成引号里的命令行，然后将其结果替换出来，再重组成新的命令行。 执行命令:</p><ol><li><code>`ls /etc`</code> : 反引号 （所有的unix系统都支持）</li><li><code>$(ls /etc)</code> : $+() （部分unix系统不支持）</li></ol><p>多个嵌套使用时，从内向外执行<code>for file in \\s /etc\\</code> 或 <code>for file in $(ls /etc)</code>循环中使用</p><p><code>path=$(cd `dirname $0`;pwd)</code> : 获取脚本当前所在目录，并且执行cd命令到达该目录，使用pwd获取路径并赋值到path变量</p><h3 id="算术运算" tabindex="-1"><a class="header-anchor" href="#算术运算"><span>算术运算</span></a></h3><p>1.$[ ] : 加减乘除,不必添加空格<br> 2.$(( )) :加减乘除等,不必添加空格</p><h3 id="逻辑判断" tabindex="-1"><a class="header-anchor" href="#逻辑判断"><span>逻辑判断</span></a></h3><p>1.[ ] : 中括号旁边和运算符两边必须添加空格 （可以使用，不推荐）</p><p>2.[[ ]]:中括号旁边和运算符两边必须添加空格 （字符串验证时，推荐使用）</p><p>3.(()) : 中括号旁边和运算符两边必须添加空格 （数字验证时，推荐使用）</p><p>4.[[]] 和 (()) 分别是[ ]的针对数学比较表达式和字符串表达式的加强版。</p><p>5.使用[[ ... ]]条件判断结构，而不是[ ... ]，能够防止脚本中的许多逻辑错误。比如，&amp;&amp;、||、&lt;和&gt; 操作符能够正常存在于[[ ]]条件判断结构中，但是如果出现在[ ]结构中的话，会报错。比如可以直接使用if [[ $a != 1 &amp;&amp; $a != 2 ]], 如果不适用双括号, 则为if [ $a -ne 1] &amp;&amp; [ $a != 2 ]或者if [ $a -ne 1 -a $a != 2 ]。</p><p>[[ ]]中增加模式匹配特效；</p><p>(( ))不需要再将表达式里面的大小于符号转义，除了可以使用标准的数学运算符外，还增加了以下符号 <img src="'+t+`" alt="逻辑判断" loading="lazy"></p><h2 id="输出" tabindex="-1"><a class="header-anchor" href="#输出"><span>输出</span></a></h2><h3 id="echo" tabindex="-1"><a class="header-anchor" href="#echo"><span>echo</span></a></h3><p>仅用于字符串的输出，没有使用printf作为输出的移植性好，建议使用printf</p><h3 id="printf" tabindex="-1"><a class="header-anchor" href="#printf"><span>printf</span></a></h3><blockquote><p>printf 不会像 echo 自动添加换行符，我们可以手动添加 \\n无大括号，直接以空格分隔</p></blockquote><ul><li>格式:printf format-string [arguments...] 其中（format-string: 格式控制字符串、arguments: 参数列表）</li><li>案例:printf &quot;%-10s %-8s %-4.2f\\n&quot; 郭靖 男 66.1234</li><li>%s %c %d %f 都是格式替代符 <ul><li>d:Decimal 十进制整数 对应位置参数必须是十进制整数，否则报错!</li><li>s:String 字符串 对应位置参数必须是字符串或者字符型 否则报错</li><li>c:Char 字符 对应位置参数必须是字符串或者字符型 否则报错</li><li>f:Float 浮点 对应位置参数必须是数字型 否则报错</li></ul></li><li>%-10s ： 指一个宽度为10个字符（-表示左对齐，没有则表示右对齐），任何字符都会被显示在10个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。</li><li>%-4.2f ：指格式化为小数，宽度为4个字符，其中.2指保留2位小数。</li><li>转义符： <ul><li>\\a ：警告字符，通常为ASCII的BEL字符</li><li>\\b ：后退</li><li>\\c ：抑制（不显示）输出结果中任何结尾的换行字符（只在%b格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略</li><li>\\f ：换页（formfeed）</li><li>\\n ：换行</li><li>\\r ：回车（Carriage return）</li><li>\\t ：水平制表符</li><li>\\v ：垂直制表符</li><li>\\ ：一个字面上的反斜杠字符</li><li>\\ddd ：表示1到3位数八进制值的字符。仅在格式字符串中有效</li><li>\\0ddd ：表示1到3位的八进制值字符</li></ul></li></ul><h2 id="重定向" tabindex="-1"><a class="header-anchor" href="#重定向"><span>重定向</span></a></h2><ol><li><p>一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：</p><ul><li><strong>标准输入文件(stdin)</strong>：stdin的文件描述符为0，Unix程序默认从stdin读取数据。</li><li><strong>标准输出文件(stdout)</strong>：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。</li><li><strong>标准错误文件(stderr)</strong>：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。</li></ul></li><li><p>默认情况下，command &gt; file 将 stdout 重定向到 file，command &lt; file 将stdin 重定向到 file。</p></li><li><p>如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null</p></li></ol><h3 id="输入重定向" tabindex="-1"><a class="header-anchor" href="#输入重定向"><span>输入重定向</span></a></h3><ol><li>bash.sh &lt; file ： 将脚本的输入重定向到file，由file提供参数</li></ol><h3 id="输出重定向" tabindex="-1"><a class="header-anchor" href="#输出重定向"><span>输出重定向</span></a></h3><ol><li><p>bash.sh &gt; file ： 将脚本的输出数据重定向到file中，覆盖数据</p></li><li><p>bash.sh &gt;&gt; file ： 将脚本的输出数据重定向到file中，追加数据</p></li><li><p>command &gt;&gt; file 2&gt;&amp;1 ： 将 stdout 和 stderr 合并后重定向到 file</p></li></ol><h3 id="读取外部输入" tabindex="-1"><a class="header-anchor" href="#读取外部输入"><span>读取外部输入</span></a></h3><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token builtin class-name">read</span> arg <span class="token comment">#脚本读取外部输入并赋值到变量上</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在shell脚本执行到上述命令时，停止脚本执行并等待外部输入，将外部输入赋值到arg变量上，继续执行脚本。</p><h3 id="文件引用" tabindex="-1"><a class="header-anchor" href="#文件引用"><span>文件引用</span></a></h3><p>引用其他的文件之后，可以使用其变量、函数等等，相当于将引用的文件包含进了当前文件</p><ul><li><strong>.</strong> file_path/file_name</li><li><strong>source</strong> file_path/file_name</li></ul><h3 id="颜色标识" tabindex="-1"><a class="header-anchor" href="#颜色标识"><span>颜色标识</span></a></h3><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token builtin class-name">printf</span> <span class="token string">&quot;<span class="token entity" title="\\033">\\033</span>[32m SUCCESS: yay <span class="token entity" title="\\033">\\033</span>[0m<span class="token entity" title="\\n">\\n</span>&quot;</span><span class="token punctuation">;</span>
<span class="token builtin class-name">printf</span> <span class="token string">&quot;<span class="token entity" title="\\033">\\033</span>[33m WARNING: hmm <span class="token entity" title="\\033">\\033</span>[0m<span class="token entity" title="\\n">\\n</span>&quot;</span><span class="token punctuation">;</span>
<span class="token builtin class-name">printf</span> <span class="token string">&quot;<span class="token entity" title="\\033">\\033</span>[31m ERROR: fubar <span class="token entity" title="\\033">\\033</span>[0m<span class="token entity" title="\\n">\\n</span>&quot;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果： <img src="`+n+'" alt="颜色标识" loading="lazy"></p><h2 id="shell脚本调试" tabindex="-1"><a class="header-anchor" href="#shell脚本调试"><span>shell脚本调试</span></a></h2><blockquote><p>在绝大多数 shell 脚本中，exit 0 表示执行成功，exit 1 表示发生错误。对错误与错误码进行一对一的映射，这样有助于脚本调试。</p></blockquote><h3 id="错误退出" tabindex="-1"><a class="header-anchor" href="#错误退出"><span>错误退出</span></a></h3><p><strong>set</strong>：set -e 或者 set +e<br><code>set -e</code>表示从当前位置开始，如果出现任何错误都将触发exit。相反，set +e表示不管出现任何错误继续执行脚本。</p><blockquote><p>如果脚本是有状态的（每个后续步骤都依赖前一个步骤），那么请使用set -e，在脚本出现错误时立即退出脚本。如果要求所有命令都要执行完（很少会这样），那么就使用set +e。</p></blockquote><h3 id="语法检测" tabindex="-1"><a class="header-anchor" href="#语法检测"><span>语法检测</span></a></h3><p>检查是否有语法错误：<code>bash -n script_name.sh</code></p><h3 id="调试" tabindex="-1"><a class="header-anchor" href="#调试"><span>调试</span></a></h3><p>查看脚本每一步输出：<code>bash -x script_name.sh</code></p><blockquote><p>输出中带有 + 表示的是 Shell 调试器的输出，不带 + 表示程序的输出。</p></blockquote>',89),r=[o];function c(d,h){return l(),i("div",null,r)}const m=e(s,[["render",c],["__file","shell.html.vue"]]),f=JSON.parse('{"path":"/software/programming/shell/shell.html","title":"一篇教会你写90%的shell脚本","lang":"zh-CN","frontmatter":{"title":"一篇教会你写90%的shell脚本","icon":"shell","category":"Java","description":"注释 \\"#\\" 开头的就是注释，被编译器忽略 单行注释: # 多行注释: :< 变量 变量类型 运行shell时，会同时存在三种变量: 局部变量:局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。 环境变量:所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要...","head":[["meta",{"property":"og:url","content":"https://yuhaoxiang.github.io/work-blog/work-blog/software/programming/shell/shell.html"}],["meta",{"property":"og:site_name","content":"大杂烩"}],["meta",{"property":"og:title","content":"一篇教会你写90%的shell脚本"}],["meta",{"property":"og:description","content":"注释 \\"#\\" 开头的就是注释，被编译器忽略 单行注释: # 多行注释: :< 变量 变量类型 运行shell时，会同时存在三种变量: 局部变量:局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。 环境变量:所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-28T08:47:19.000Z"}],["meta",{"property":"article:author","content":"yhx"}],["meta",{"property":"article:modified_time","content":"2024-04-28T08:47:19.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"一篇教会你写90%的shell脚本\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-04-28T08:47:19.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"yhx\\",\\"url\\":\\"/\\"}]}"]]},"headers":[{"level":2,"title":"注释","slug":"注释","link":"#注释","children":[]},{"level":2,"title":"变量","slug":"变量","link":"#变量","children":[{"level":3,"title":"变量类型","slug":"变量类型","link":"#变量类型","children":[]},{"level":3,"title":"变量操作","slug":"变量操作","link":"#变量操作","children":[]},{"level":3,"title":"字符串变量","slug":"字符串变量","link":"#字符串变量","children":[]},{"level":3,"title":"单引号","slug":"单引号","link":"#单引号","children":[]},{"level":3,"title":"双引号","slug":"双引号","link":"#双引号","children":[]},{"level":3,"title":"拼接字符串","slug":"拼接字符串","link":"#拼接字符串","children":[]},{"level":3,"title":"获取字符串长度","slug":"获取字符串长度","link":"#获取字符串长度","children":[]},{"level":3,"title":"提取子字符串","slug":"提取子字符串","link":"#提取子字符串","children":[]}]},{"level":2,"title":"数组","slug":"数组","link":"#数组","children":[]},{"level":2,"title":"参数传递","slug":"参数传递","link":"#参数传递","children":[]},{"level":2,"title":"运算符","slug":"运算符","link":"#运算符","children":[{"level":3,"title":"算数运算","slug":"算数运算","link":"#算数运算","children":[]},{"level":3,"title":"数字关系运算符","slug":"数字关系运算符","link":"#数字关系运算符","children":[]},{"level":3,"title":"字符串运算符","slug":"字符串运算符","link":"#字符串运算符","children":[]},{"level":3,"title":"布尔运算符","slug":"布尔运算符","link":"#布尔运算符","children":[]},{"level":3,"title":"逻辑运算符","slug":"逻辑运算符","link":"#逻辑运算符","children":[]},{"level":3,"title":"文件运算符","slug":"文件运算符","link":"#文件运算符","children":[]}]},{"level":2,"title":"执行相关","slug":"执行相关","link":"#执行相关","children":[{"level":3,"title":"命令替换","slug":"命令替换","link":"#命令替换","children":[]},{"level":3,"title":"算术运算","slug":"算术运算","link":"#算术运算","children":[]},{"level":3,"title":"逻辑判断","slug":"逻辑判断","link":"#逻辑判断","children":[]}]},{"level":2,"title":"输出","slug":"输出","link":"#输出","children":[{"level":3,"title":"echo","slug":"echo","link":"#echo","children":[]},{"level":3,"title":"printf","slug":"printf","link":"#printf","children":[]}]},{"level":2,"title":"重定向","slug":"重定向","link":"#重定向","children":[{"level":3,"title":"输入重定向","slug":"输入重定向","link":"#输入重定向","children":[]},{"level":3,"title":"输出重定向","slug":"输出重定向","link":"#输出重定向","children":[]},{"level":3,"title":"读取外部输入","slug":"读取外部输入","link":"#读取外部输入","children":[]},{"level":3,"title":"文件引用","slug":"文件引用","link":"#文件引用","children":[]},{"level":3,"title":"颜色标识","slug":"颜色标识","link":"#颜色标识","children":[]}]},{"level":2,"title":"shell脚本调试","slug":"shell脚本调试","link":"#shell脚本调试","children":[{"level":3,"title":"错误退出","slug":"错误退出","link":"#错误退出","children":[]},{"level":3,"title":"语法检测","slug":"语法检测","link":"#语法检测","children":[]},{"level":3,"title":"调试","slug":"调试","link":"#调试","children":[]}]}],"git":{"createdTime":1714294039000,"updatedTime":1714294039000,"contributors":[{"name":"haoxiang.yu@sectrend.com.cn","email":"ZLJw5dEMQLaVgsP","commits":1}]},"readingTime":{"minutes":11.46,"words":3437},"filePathRelative":"software/programming/shell/shell.md","localizedDate":"2024年4月28日","autoDesc":true}');export{m as comp,f as data};
